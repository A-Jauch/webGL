<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - FBX loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	<!-- -->	
		<style>
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.2);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				font-family: Arial;
				font-size: 14px;
				line-height: 24px;

				cursor: pointer;
			}
		</style> 
	</head>

	<body>
<!-- div des instructions -->
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:36px">Click to start</span>
				<br /><br />
				Move: WASD<br/>
				Jump: SPACE<br/>
				Look: MOUSE
			</div>

		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			//controls pointerlocks
			import { PointerLockControls } from './jsm/controls/PointerLockControls.js';

			var doorGroup, dresserGroup, container, stats, controls, doorpoint;
			var camera, scene, renderer, light, raycaster;
			var objects = [];
;

			var clock = new THREE.Clock();

			var mixer;
//OrbitControls pointerlocks ---------------------
			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();
// -----------------------
			//init();
			animate();

			function init() {

			//	container = document.createElement( 'div' );
			//	document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.set(1000, 800, 1000 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xa0a0a0 );
			//	scene.fog = new THREE.Fog( 0xa0a0a0, 200, 1000 );

// controls ----------------------
				controls = new PointerLockControls( camera );

				var blocker = document.getElementById( 'blocker' );
				var instructions = document.getElementById( 'instructions' );

				instructions.addEventListener( 'click', function () {

					controls.lock();

				}, false ); 

				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';

				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';

				} );

				scene.add( controls.getObject() );


       			var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 850;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );


				//end con --------------------


				light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				light.position.set( 0, 200, 0 );
				scene.add( light );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 200, 100 );
				light.castShadow = true;
				light.shadow.camera.top = 180;
				light.shadow.camera.bottom = - 100;
				light.shadow.camera.left = - 120;
				light.shadow.camera.right = 120;
				scene.add( light );

				// scene.add( new CameraHelper( light.shadow.camera ) );

				// ground
				var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.material.transparent = true;
				scene.add( grid );

		
				var doorFeatures = [360, 800, 30];
				var doorPosition = [-200, 0, 0];
				var centerPointPosition = [100, doorFeatures[1]/2, 1025];
				
		
// point

				var rotationPointGeometry = new THREE.SphereBufferGeometry( 1, 1, 1000 );
				var rotationPointMaterial = new THREE.MeshBasicMaterial( { color : 0x000000 } );
				var rotationPoint = new THREE.Mesh( rotationPointGeometry, rotationPointMaterial );
				rotationPoint.position.set(0,0,0);
				doorGroup = new THREE.Group();	
				doorGroup.applyMatrix( new THREE.Matrix4().makeTranslation(centerPointPosition[0], centerPointPosition[1], centerPointPosition[2]) );
				scene.add(doorGroup);
				doorGroup.add( rotationPoint );

//door

				var doorTexture = new THREE.TextureLoader().load( 'textures/4panel.jpg' );

				var doorGeometry = new THREE.CubeGeometry(doorFeatures[0], doorFeatures[1], doorFeatures[2]);
				var doorMaterial = new THREE.MeshBasicMaterial( {map: doorTexture } );
				var door = new THREE.Mesh( doorGeometry, doorMaterial );
				door.position.set(doorPosition[0], doorPosition[1], doorPosition[2]);
				doorGroup.add( door );

//handle
				var handleTexture = new THREE.TextureLoader().load( 'textures/poignee.jpg' );
				var handleGeometry = new THREE.SphereBufferGeometry( 15, 15, 1000 );
				var handleMaterial = new THREE.MeshBasicMaterial( { map: handleTexture } );
				var handlePosition = [doorPosition[0] - 140, doorPosition[1] * 0.87, doorPosition[2]];

				var handle = new THREE.Mesh( handleGeometry, handleMaterial );
				handle.position.set(handlePosition[0], handlePosition[1], handlePosition[2] + 50);
				doorGroup.add( handle );

				var handle2 = handle.clone();
				handle2.position.z = handlePosition[2] - 50;
				doorGroup.add( handle2 );

//cylinder between handles
				var betweenHandleGeometry = new THREE.CylinderGeometry( 5, 5, 100, 30 );
				var betweenHandleMaterial = new THREE.MeshBasicMaterial( { map: handleTexture } );
				var betweenHandle = new THREE.Mesh( betweenHandleGeometry, betweenHandleMaterial );
				betweenHandle.position.set(handlePosition[0], handlePosition[1], handlePosition[2]);
				betweenHandle.rotation.x = Math.PI/2;
				doorGroup.add( betweenHandle );
				scene.add( doorGroup );
				objects.push( doorGroup);
				

//dresser
			//	var dresserFootPosition = [750, 25, 800];
			var dresserFootPosition = [0, 0, 0];
				var dresserGroup = new THREE.Group();
				dresserGroup.applyMatrix( new THREE.Matrix4().makeTranslation(750, 25, 800) );
				dresserGroup.rotation.y = Math.PI/3;
    			var dresserFootGeometry = new THREE.CylinderGeometry( 5, 5, 50, 300 );
  				var dresserFootTexture = new THREE.TextureLoader().load('textures/wood.jpg');
			    var dresserFootMaterial = new THREE.MeshBasicMaterial( { map : dresserFootTexture } );
    			var dresserFoot = new THREE.Mesh( dresserFootGeometry, dresserFootMaterial );
    			dresserFoot.position.set(dresserFootPosition[0] +160, dresserFootPosition[1], dresserFootPosition[2] -60);
    			dresserGroup.add( dresserFoot );

    			var dresserFoot2 = dresserFoot.clone();
    			dresserFoot2.position.set(dresserFootPosition[0] +160, dresserFootPosition[1], dresserFootPosition[2] +60);
    			dresserGroup.add( dresserFoot2 );

    			var dresserFoot3 = dresserFoot.clone();
    			dresserFoot3.position.set(dresserFootPosition[0] -160, dresserFootPosition[1], dresserFootPosition[2] -60);
    			dresserGroup.add( dresserFoot3 );

    			var dresserFoot4 = dresserFoot.clone();
    			dresserFoot4.position.set(dresserFootPosition[0] -160, dresserFootPosition[1], dresserFootPosition[2] +60);
    			dresserGroup.add( dresserFoot4 );


				var dresserTexture = new THREE.TextureLoader().load( 'textures/wood.jpg' );
	        	var dresserGeometry = new THREE.CubeGeometry(350, 10, 140);
    	    	var dresserMaterial = new THREE.MeshBasicMaterial( {map: dresserTexture } );
        		var dresser = new THREE.Mesh( dresserGeometry, dresserMaterial );
        		dresser.position.set(dresserFootPosition[0], dresserFootPosition[1]+30, dresserFootPosition[2]);
        		dresserGroup.add( dresser );

        		var dresser2 = dresser.clone();
        		dresser2.position.set(dresserFootPosition[0], dresserFootPosition[1]+130, dresserFootPosition[2]);
        		dresserGroup.add( dresser2 );

        		var dresser3Texture = new THREE.TextureLoader().load( 'textures/wood.jpg' );
	        	var dresser3Geometry = new THREE.CubeGeometry(110, 10, 140);
    	    	var dresser3Material = new THREE.MeshBasicMaterial( {map: dresserTexture } );
        		var dresser3 = new THREE.Mesh( dresser3Geometry, dresser3Material );
        		dresser3.position.set(dresserFootPosition[0] + 175, dresserFootPosition[1]+80, dresserFootPosition[2]);
        		dresser3.rotation.z = Math.PI/2;
        		dresserGroup.add( dresser3 );

        		var dresser4 = dresser3.clone();
        		dresser4.position.set(dresserFootPosition[0] - 175, dresserFootPosition[1]+80, dresserFootPosition[2]);
        		dresser4.rotation.z = Math.PI/2;
        		dresserGroup.add( dresser4 );

        		scene.add( dresserGroup );
        		objects.push(dresserGroup);

				// model
			// 	var loader = new FBXLoader();
			// 	loader.load( 'models/fbx/soccerball/Cheap Soccer Ball/model/FBX/ball.fbx', function ( object ) {

			// 		mixer = new THREE.AnimationMixer( object );
					

			// 		var action = mixer.clipAction( object.animations[ 0 ] );
			// 		action.play();
			// 		object.traverse( function ( child ) {

			// 			if ( child.isMesh ) {

			// 				child.castShadow = true;
			// 				child.receiveShadow = true;
			// 			}

			// 		} );
			// 		object.scale.set(1/4, 1/4, 1/4);
			// 		object.position.set(0,100,0);
			// 		scene.add( object );

			// // 		function move(speed) {
			// // 			var d = mesh.position.x - mesh2.position.x;
			// // 			if (mesh.position.x > mesh2.position.x) {
			// //    			mesh.position.x -= Math.min( speed, d );
			// //   		}
			// // }
			// 	} );



				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				//container.appendChild( renderer.domElement );
				document.body.appendChild( renderer.domElement );
			//	controls = new OrbitControls( camera, renderer.domElement );
			//	controls.target.set( 0, 100, 0 );
			//	controls.update();

				window.addEventListener( 'resize', onWindowResize, false );

				// stats
				stats = new Stats();
				document.body.appendChild( stats.dom );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
	
				if ( controls.isLocked === true ) {

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					var intersections = raycaster.intersectObjects( objects );

					var onObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 4000.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 4000.0 * delta;

					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					if ( controls.getObject().position.y < 100 ) {

						velocity.y = 0;
						controls.getObject().position.y = 100; // 

						canJump = true;

					}

					prevTime = time;

				}


				var delta = clock.getDelta();

				if ( mixer ) mixer.update( delta );

				renderer.render( scene, camera );

				stats.update();

				doorGroup.rotation.y -= 0.0;
			}

		</script>

	</body>
</html>
